Это код для предсказания исхода международных футбольных матчей по данным GitHub-датасета international_results, с использованием логистической регрессии и нейронной сети на Keras.

Ниже — текстовое описание в формате, максимально близком к структуре самого кода, чтобы ты мог использовать его как пояснительную записку.

***

## Введение

В работе используется датасет международных футбольных матчей `results.csv`, содержащий результаты игр сборных с 1872 года, включая дату матча, команды, счёт, турнир и страну проведения.
Цель программы — построить и сравнить две модели классификации исходов матча (победа хозяев, ничья, победа гостей): базовую модель логистической регрессии и многослойную нейросеть TensorFlow/Keras на основе one-hot представления категориальных признаков.

***

## Загрузка и подготовка данных

Вначале подключаются необходимые библиотеки: `pandas`, `numpy`, `scikit-learn`, `tensorflow/keras`, `requests` и `matplotlib`. Они используются для обработки таблиц, построения моделей, загрузки данных из сети и визуализации обучения.

Датасет загружается по адресу:
```python
DATA_URL = "https://raw.githubusercontent.com/martj42/international_results/master/results.csv"
```
Этот файл содержит результаты международных матчей: дату, команды, голы хозяев и гостей, название турнира, город и страну проведения.

Далее реализован механизм:
- попытка прочитать локальный `data.csv`;
- при ошибке — скачивание исходного CSV по `DATA_URL` и сохранение его локально, затем повторное чтение.

После загрузки создаётся новый столбец `outcome` через функцию `determine_outcome`:
- `2` — победа хозяев (home_score > away_score),
- `1` — ничья,
- `0` — победа гостей.  

Пропуски по полям `home_score`, `away_score`, `date` удаляются, чтобы гарантировать корректное вычисление исхода.

Затем дата приводится к типу `datetime`, и выборка ограничивается матчами с 2010 года, чтобы модель обучалась на более современных играх.

***

## Формирование признаков и разбиение на выборки

Выбираются три категориальных признака:
- `home_team` — команда хозяев,
- `away_team` — команда гостей,
- `country` — страна проведения матча.

Целевая переменная `target` — столбец `outcome` с тремя классами (0, 1, 2).  

Далее данные делятся на обучающую и тестовую выборки:
```python
train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)
```
- 80% данных — обучение,
- 20% — тест,  
- используется стратификация по классам, чтобы сохранять распределение исходов в обоих поднаборах.

***

## Пайплайн Scikit-learn с логистической регрессией

Для обработки категориальных признаков применяется `ColumnTransformer` с `OneHotEncoder`:
- каждая команда и страна кодируются в вектор из нулей и единиц (one-hot), что позволяет использовать их в линейной модели.

Создаётся `Pipeline`, который:
1) сначала применяет one-hot кодирование к признакам;
2) затем обучает модель `LogisticRegression`.

Параметры логистической регрессии:
- `max_iter=2000` — число итераций оптимизации, чтобы гарантировать сходимость;
- `C=2.0` — коэффициент регуляризации (чем больше C, тем слабее L2-регуляризация);
- `class_weight="balanced"` — веса классов выбираются обратно пропорционально частотам, что помогает при дисбалансе исходов (например, если ничьих меньше побед).

После обучения на `X_train, y_train` вычисляются предсказания для `X_test`, а затем формируется отчёт `classification_report`, содержащий:
- точность (precision),
- полноту (recall),
- F1-меру,
- общую accuracy для всех классов исходов.

Эта модель служит базовой (baseline), с которой затем сравнивается нейросеть.

***

## Подготовка данных для Keras

Далее те же обучающие данные пропускаются через уже обученный `preprocess`, чтобы получить разреженные one-hot матрицы `X_train_ohe` и `X_test_ohe`. Размерность признакового пространства `input_dim` — количество всех возможных комбинаций значений `home_team`, `away_team` и `country`.

Целевая переменная кодируется в формат one-hot:
- класс 0 → `[1, 0, 0]`,
- класс 1 → `[0, 1, 0]`,
- класс 2 → `[0, 0, 1]`.  

Это требуется для использования функции потерь `categorical_crossentropy` в Keras.

Чтобы компенсировать дисбаланс классов, вычисляются веса:
```python
compute_class_weight("balanced", classes=np.unique(y_train), y=y_train)
```
Результат преобразуется в словарь `class_weights = {0: w0, 1: w1, 2: w2}` и далее передаётся при обучении, чтобы ошибки по редким исходам давали больший вклад в функцию потерь.

***

## Нейросетевая модель TensorFlow/Keras

Параметры модели:
- `layers_sizes = [128, 64, 32]` — три скрытых слоя с убывающим числом нейронов;
- `activation = "relu"` — нелинейная активация ReLU для скрытых слоёв;
- `dropout_rate = 0.3` — регуляризация Dropout с отбрасыванием 30% нейронов;
- `learning_rate = 1e-3` — скорость обучения оптимизатора Adam;
- `epochs = 100`, `batch_size = 128` — параметры процесса обучения (число эпох и размер мини-батча).

Архитектура строится как `Sequential`:
1) Входной слой `Input(shape=(input_dim,))` принимает one-hot вектор признаков.
2) В цикле добавляются скрытые слои:
   - `Dense(units, activation="relu")` — полносвязный слой для извлечения нелинейных зависимостей между командами и страной;
   - `Dropout(0.3)` — случайное «выключение» части нейронов, снижает переобучение;  
   - `BatchNormalization()` — нормализация активаций, стабилизирует градиенты и ускоряет обучение.  
3) Выходной слой: `Dense(num_classes, activation="softmax")` — выдаёт распределение вероятностей по трём исходам, сумма которых равна 1.

Компиляция:
```python
model.compile(
    optimizer=Adam(learning_rate=1e-3),
    loss="categorical_crossentropy",
    metrics=["accuracy"],
)
```
- `categorical_crossentropy` — стандартная функция потерь для многоклассовой классификации с one-hot целями;
- `accuracy` — доля правильно предсказанных исходов.

***

## Обучение и визуализация

Модель обучается на `X_train_ohe, y_train_cat`:
- `validation_split=0.1` — 10% обучающих данных используются для валидации;
- `class_weight=class_weights` — учёт дисбаланса классов при расчёте потерь.

В процессе обучения сохраняются значения:
- `history.history['loss']` — значение функции потерь на обучающей выборке,
- `history.history['accuracy']` — точность на обучающей выборке.

С помощью `matplotlib` строится график:
- по оси X — номер эпохи;
- по оси Y — значения loss и accuracy;
- график позволяет визуально оценить, как модель обучается и есть ли признаки переобучения (например, если loss перестаёт уменьшаться или точность насыщается).

***

## Оценка качества нейросети

Для тестовой выборки:
```python
probs = model.predict(X_test_ohe)
y_pred_nn = probs.argmax(axis=1)
```
получаются предсказания классов как индекс максимальной вероятности.  

Далее снова используется `classification_report(y_test, y_pred_nn)`, что позволяет:
- сравнить качество нейросети с логистической регрессией на тех же данных;
- оценить точность по каждому классу исхода и общее качество модели.

***

## Функция прогнозирования матча

Определена функция:
```python
def predict_match(home_team, away_team, tournament, country):
```
Она:
- создаёт DataFrame с одной строкой и колонками `home_team`, `away_team`, `country`;
- пропускает его через тот же `preprocess`, что и обучающие данные;
- применяет `model.predict` для получения вероятностей исходов;
- выбирает класс с максимальной вероятностью и возвращает:
  - текстовую метку (`"Победа гостей"`, `"Ничья"`, `"Победа хозяев"`);
  - вектор вероятностей `p`.

Пользователь вводит:
- страну-хозяина (`home_team`),
- страну-гостя (`away_team`),
- класс встречи (`tournament`, в текущей версии в модель не входит),
- страну проведения (`country`),

после чего программа печатает:
- текстовый прогноз исхода,
- вероятности каждого из трёх исходов в процентах.

***

## Итог

Код реализует полный цикл работы с реальным футбольным датасетом: от загрузки и предобработки данных до обучения и сравнения двух моделей (логистической регрессии и нейросети), а также предоставляет интерактивную функцию предсказания исхода конкретного матча по введённым пользователем командам и стране проведения.

